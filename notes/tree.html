<!DOCTYPE html>
<html lang="en" dir="ltr">


<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trees</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
</head>


<body>
  <div class="topnav" id="myTopnav">
    <a href="index.html">Home</a>
    <a href="previous_year.html">Previous year paper</a>
    <a href="algorithm.html">Algorithms</a>
    <a href="notes.html" class="active">Notes</a>
    <a href="about.html">About us</a>
    <input type="text" placeholder="Search Algorithm" />
    <a href="javascript:void(0);" class="icon" onclick="myFunction()">
      <i class="fa fa-bars"></i>
    </a>
  </div>


  <div class="second-nav">
      <div class="dropdown">
        <button class="dropbtn">Data Structure
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
        <a href="array.html">Array</a>
        <a href="string.html">String</a>
        <a href="matrix.html">Matrix</a>
        <a href="linkedlist.html">Linked List</a>
        <a href="stacks.html">Stack</a>
        <a href="queue.html">Queue</a>
        <a href="tree.html">Binary Tree</a>
        <a href="tree.html">Binary Search Tree</a>
        <a href="heap.html">Heap</a>
        <a href="hashing.html">Hashing</a>
        <a href="graph.html">Graph</a>
        </div>
      </div>


      <div class="dropdown">
        <button class="dropbtn">Advanced Data Structure
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
        <a href="#">Trie</a>
        <a href="#">Disjoint Sets</a>
        <a href="#">Segment Tree</a>
        <a href="#">Self Balancing Tree</a>
        </div>
      </div>


      <div class="dropdown">
        <button class="dropbtn">Algorithms
            <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
        <a href="#">Analysis of Algorithm</a>
        <a href="../algorithm.html#searching_algo">Searching Algorithm</a>
        <a href="../algorithm.html#sorting_algo">Sorting Algorithm</a>
        <a href="#">Graph</a>
        <a href="#">Pattern-Searching</a>
        <a href="../algorithm.html#math_algo">Mathematical</a>
        <a href="../algorithm.html#bit_algo"">Bitwise</a>
        <a href="../algorithm.html#greedy_algo">Greedy</a>
        <a href="../algorithm.html#dp_algo">Dynamic Programming</a>
        <a href="../algorithm.html#dandc_algo">Divide and Conquer</a>
        <a href="../algorithm.html#backtracking_algo">Backtracking</a>
        <a href="../algorithm.html#bandb_algo">Branch & Bound</a>
        </div>
      </div>
  </div>

  <div class="container">
    <div class="item left-side">
      <img class="left-side-image" src="../images/datastr.png" alt="">
      <h3>Quick Links</h3>
      <h2 class="left-heading"><a class="left-side-heading" href="#">Data Structure</a></h2>
      <ul>
        <li class="leftls"><a class="left-side-list" href="array.html">Array</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="string.html">String</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="matrix.html">Matrix</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="linkedlist.html">Linked List</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="stacks.html">Stack</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="queue.html">Queue</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="tree.html">Binary Tree</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="tree.html">Binary Search Tree</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="heap.html">Heap</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="hashing.html">Hashing</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="graph.html">Graph</a></li>
      </ul>
      <h2 class="left-heading"><a class="left-side-heading" href="#">Advanced Data Structure</a></h2>
      <ul>
        <li class="leftls"><a class="left-side-list" href="#">Trie</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="#">Disjoint Sets</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="#">Segment Tree</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="#">Self Balancing Tree</a></li>
        <hr>
      </ul>
      <h2 class="left-heading"><a class="left-side-heading" href="#">Algorithms</a></h2>
      <ul>
        <li class="leftls"><a class="left-side-list" href="#">Analysis of Algorithm</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#searching_algo">Searching Algorithm</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#sorting_algo">Sorting Algorithm</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="#">Graph</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="#">Pattern Searching</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#math_algo">Mathematical</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#bit_algo">Bitwise</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#greedy_algo">Greedy</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#dp_algo">Dynamic Programming</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#dandc_algo">Divide and Conquer</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#backtracking_algo">Backtracking</a></li>
        <hr>
        <li class="leftls"><a class="left-side-list" href="../algorithm.html#bandb_algo">Branch & Bound</a></li>
        <hr>
      </ul>
    </div>


      <div class="item middle">
        <h1>Binary Tree</h1>
        A tree is non-linear and a hierarchical data structure consisting of a collection of nodes such that each node of the tree stores a value, a list of references to nodes (the “children”).
      <br>
      Binary Tree is a special datastructure used for data storage purposes. A binary tree has a special condition that each node can have a maximum of two children. A binary tree has the benefits of both an ordered array and a linked list as search is as quick as in a sorted array and insertion or deletion operation are as fast as in linked list.
<br>
      <img class="array-img" src="../images/binary_tree.jpg" alt="">
      <br>
      <h2>Important Terms</h2>
      <h3>Following are the important terms with respect to tree.</h3>
      <ul style="list-style-type:circle">
        <li>
          <strong>Path: </strong>Path refers to the sequence of nodes along the edges of a tree.
        </li>
        <li>
          <strong>Root: </strong>The node at the top of the tree is called root. There is only one root per tree and one path from the root node to any node.
        </li>
        <li>
          <strong>Parent: </strong>Any node except the root node has one edge upward to a node called parent.
        </li>
        <li>
          <strong>Child: </strong>The node below a given node connected by its edge downward is called its child node.
        </li>
        <li>
          <strong>Leaf: </strong>The node which does not have any child node is called the leaf node.
        </li>
        <li>
          <strong>Subtree: </strong> Subtree represents the descendants of a node.
        </li>
        <li>
          <strong>Visiting: </strong> Visiting refers to checking the value of a node when control is on the node.
        </li>
        <li>
          <strong>Traversing: </strong>Traversing means passing through nodes in a specific order.
        </li>
        <li>
          <strong>Levels: </strong>Level of a node represents the generation of a node. If the root node is at level 0, then its next child node is at level 1, its grandchild is at level 2, and so on.
        </li>
        <li>
          <strong>keys: </strong>Key represents a value of a node based on which a search operation is to be carried out for a node.
        </li>
      </ul>
      <br>
    <h2>Binary Search Tree</h2>
    <p>Binary Search tree exhibits a special behavior. A node's left child must have a value less than its parent's value and the node's right child must have a value greater than its parent value.</p>
    <img class="array-img" src="../images/binary_search_tree.jpg" alt="">
    <br>
    <h2>Node Representation</h2>
    <p class="structure">
      struct node { <br>
     int data;   <br>
     struct node *leftChild; <br>
     struct node *rightChild; <br>
  };</p>
    <h2>Basic Operations On BST</h2>
    <p>The basic operations that can be performed on a binary search tree data structure, are the following:</p>
    <ul style="list-style-type:circle">
      <li>
        <strong>Insert: </strong>Inserts an element in a tree/create a tree.
      </li>
      <li>
        <strong>Search: </strong>Searches an element in a tree.
      </li>
      <li>
        <strong>Preorder Traversal: </strong> Traverses a tree in a pre-order manner.
      </li>
      <li>
        <strong>Inorder Traversal: </strong>Traverses a tree in an in-order manner.
      </li>
      <li>
        <strong>Postorder Traversal: </strong>Traverses a tree in a post-order manner.
      </li>
    </ul>
    <br>
    <h3>Insert Operation</h3>
    <p>The very first insertion creates the tree. Afterwards, whenever an element is to be inserted, first locate its proper location. Start searching from the root node, then if the data is less than the key value, search for the empty location in the left subtree and insert the data. Otherwise, search for the empty location in the right subtree and insert the data.</p>
    <h3>Implementation</h3>
    <p class="structure">
      void insert(int data) { <br>
   struct node *tempNode = (struct node*) malloc(sizeof(struct node)); <br>
   struct node *current; <br>
   struct node *parent; <br>

   tempNode->data = data; <br>
   tempNode->leftChild = NULL; <br>
   tempNode->rightChild = NULL; <br>

   //if tree is empty, create root node
   if(root == NULL) { <br>
      root = tempNode; <br>
   } else { <br>
      current = root; <br>
      parent  = NULL; <br>

      while(1) {          <br>
         parent = current; <br>

         //go to left of the tree <br>
         if(data < parent->data) { <br>
            current = current->leftChild; <br>

            //insert to the left <br>
            if(current == NULL) { <br>
               parent->leftChild = tempNode; <br>
               return; <br>
            } <br>
         } <br>

         //go to right of the tree <br>
         else { <br>
            current = current->rightChild; <br>

            //insert to the right <br>
            if(current == NULL) { <br>
               parent->rightChild = tempNode; <br>
               return; <br>
            } <br>
         } <br>
      }        <br>
   }<br>
}
    </p>
    <br>
    <h3>Search Operation</h3>
    <p>Whenever an element is to be searched, start searching from the root node, then if the data is less than the key value, search for the element in the left subtree. Otherwise, search for the element in the right subtree. Follow the same algorithm for each node.</p>
    <h3>Implementation</h3>
    <p class="structure">struct node* search(int data) { <br>
   struct node *current = root; <br>
   printf("Visiting elements: "); <br>

   while(current->data != data) { <br>
      if(current != NULL) <br>
      printf("%d ",current->data); <br>

      //go to left tree <br>

      if(current->data > data) { <br>
         current = current->leftChild; <br>
      } <br>
      //else go to right tree <br>
      else {                <br>
         current = current->rightChild; <br>
      } <br>

      //not found <br>
      if(current == NULL) { <br>
         return NULL; <br>
      } <br>

      return current; <br>
   }  <br>
}</p>
<br>
<h2>Traversal</h2>
<p>Traversal is a process to visit all the nodes of a tree and may print their values too. Because, all nodes are connected via edges (links) we always start from the root (head) node. That is, we cannot randomly access a node in a tree. There are three ways which we use to traverse a tree −</p>
<ul style="list-style-type:circle">
  <li>
    <strong>In-order Traversal</strong>
  </li>
  <li>
    <strong>Pre-order Traversal</strong>
  </li>
  <li>
    <strong>Post-order Traversal</strong>
  </li>
</ul>
<h3>In-order Traversal</h3>
<p>In this traversal method, the left subtree is visited first, then the root and later the right sub-tree. We should always remember that every node may represent a subtree itself.
<br>
If a binary tree is traversed in-order, the output will produce sorted key values in an ascending order.</p>
<h3>ALGORITHM</h3>
<p class="structure">Until all nodes are traversed − <br>
Step 1 − Recursively traverse left subtree. <br>
Step 2 − Visit root node. <br>
Step 3 − Recursively traverse right subtree.</p>
<br>
<h3>Pre-order Traversal</h3>
<p>In this traversal method, the root node is visited first, then the left subtree and finally the right subtree.</p>
<h3>ALGORITHM</h3>
<p class="structure">Until all nodes are traversed − <br>
Step 1 − Visit root node. <br>
Step 2 − Recursively traverse left subtree. <br>
Step 3 − Recursively traverse right subtree.</p>
<br>
<h3>Post-order Traversal</h3>
<p>In this traversal method, the root node is visited last, hence the name. First we traverse the left subtree, then the right subtree and finally the root node.

</p>
<h3>ALGORITHM</h3>
<p class="structure">Until all nodes are traversed − <br>
Step 1 − Recursively traverse left subtree. <br>
Step 2 − Recursively traverse right subtree. <br>
Step 3 − Visit root node.</p>
<h2>Output of all traversals</h2>
<img class="array-img"src="../images/inorder_traversal.jpg" alt="">
<br>
<p><strong>Inorder Traversal-> D → B → E → A → F → C → G </strong></p>
<p>
  <strong>Pre-order Traversal-> A → B → D → E → C → F → G</strong>
</p>
<p>
  <strong>Post-order Traversal-> D → E → B → F → G → C → A </strong>
</p>

      </div>

      <div class="item right-side">

      </div>


      <div class="item bottom practice-prob">
          <h2 class="practice-prob-head"> Practice Problems On Binary Tree/BST</h2>

          <ul style="list-style-type:circle">
            <li>
              <a href="https://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/">Construct BST from given preorder traversal </a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/transform-bst-sum-tree/">Transform a BST to greater sum tree</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/bst-tree-sum-smaller-keys/">BST to a Tree with sum of all smaller keys</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/reverse-path-bst-using-queue/">Reverse a path in BST using queue</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/convert-normal-bst-balanced-bst/">Convert a normal BST to Balanced BST</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/merge-two-balanced-binary-search-trees/">Merge Two Balanced Binary Search Trees</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/">Merge two BSTs with limited extra space</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/">Check for Identical BSTs without building the trees</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/kth-smallest-element-in-bst-using-o1-extra-space/">K’th smallest element in BST using O(1) Extra Space</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/check-if-given-sorted-sub-sequence-exists-in-binary-search-tree/">Check if given sorted sub-sequence exists in binary search tree</a>
            </li>
            <li>
              <a href="https://www.geeksforgeeks.org/largest-number-bst-less-equal-n/">Largest number in BST which is less than or equal to N</a>
            </li>
          </ul>
          <div class="more-prob">

            <a href="../questions.html">More problems>>></a>
          </div>
            </div>
          </div>




          <footer class="footer">
          <div class="footer_div">
            <div class="footer_row">
              <div class="footer_col">
                <h4>Company</h4>
                <ul>
                  <li><a href="../about.html">About Us</a></li>
                  <li><a href="#">Privacy Policy</a></li>
                  <li><a href="#">Our Service</a></li>
                  <li><a href="#">Contact Us</a></li>
                </ul>
              </div>
              <div class="footer_col">
                <h4>Learn</h4>
                <ul>
                  <li><a href="../algorithm.html">Algorithms</a></li>
                  <li><a href="../dsa-placement.html">Data Structures</a></li>
                  <li><a href="../previous_year.html">Previous Year Papers</a></li>
                </ul>
              </div>
              <div class="footer_col">
                <h4>Support Us</h4>
                <ul>
                  <li><a href="#">Write an Article</a></li>
                  <li><a href="#">Write Interview Experience</a></li>
                  <li><a href="#">Rate Us</a></li>
                </ul>
              </div>
              <div class="footer_col">
                <h4>Follow Us</h4>
                <div class="social-links">
                  <a href="#"><i class="fa fa-facebook-f"></i></a>
                  <a href="#"><i class="fa fa-twitter"></i></a>
                  <a href="#"><i class="fa fa-instagram"></i></a>
                </div>
              </div>
            </div>
          </div>
          <button id="scrollTopBtn" title="Scroll to Top" type="button" class="btn btn-success" style="display: inline-block"    onclick="getBackToBeginning()">
            ▲
          </button>
          </footer>

          </body>

          </html>
